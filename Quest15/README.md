# Quest 15. 자동화된 테스트

## Introduction

- 이번 퀘스트에서는 자동화된 테스트에 어떤 장점이 있는지, 어떤 식으로 구축할 수 있는지에 대해 알아보겠습니다.

## Topics

- Automated Test
  - TDD
  - Unit Test
  - Integration Test
  - E2E Test
  - Stub & Mock
- Jest
- Puppeteer

## Resources

- [Unit Test (단위 테스트) 도입하기](https://www.popit.kr/unit-test-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0-1%ED%8E%B8/)
- [소프트웨어 테스트 안티 패턴](https://velog.io/@leejh3224/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%95%88%ED%8B%B0-%ED%8C%A8%ED%84%B4)
- [End-to-End testing with Puppeteer and Jest](https://medium.com/touch4it/end-to-end-testing-with-puppeteer-and-jest-ec8198145321)
- [Mock & Stub](https://stackoverflow.com/questions/3459287/whats-the-difference-between-a-mock-stub)

## Checklist

- **자동화된 테스트를 만드는 것에는 어떤 장점과 단점이 있을까요?**

**장점**:

- **시간과 비용 절감**: 자동화된 테스트는 사람이 수작업으로 수행하는 테스트보다 더 빠르고 정확하게 실행됩니다. 이는 시간과 비용을 절감할 수 있습니다.
- **일관성**: 자동화된 테스트는 일관적인 방식으로 수행됩니다. 이는 사람이 수작업으로 테스트를 수행할 때 발생할 수 있는 실수와 오류를 최소화합니다.
- **더 넓은 범위의 테스트**: 자동화된 테스트는 더 많은 테스트 케이스를 더 빠르게 실행할 수 있으므로, 테스트 범위를 더욱 확장할 수 있습니다.
- **효율적인 버그 검출**: 자동화된 테스트는 테스트 중 발견된 버그를 정확하고 빠르게 보고할 수 있습니다. 이는 버그를 더 빠르게 수정하고 배포할 수 있도록 도와줍니다.

**단점**:

1.  **초기 비용**: 자동화된 테스트를 구현하고 유지하는 데는 초기 비용이 들어갑니다. 이는 자원이 제한된 경우 문제가 될 수 있습니다.
2.  **인력 필요**: 자동화된 테스트를 만들기 위해서는 테스트 코드를 작성할 수 있는 개발자가 필요합니다. 이는 일부 기업에서는 인력을 확보하는 것이 어려울 수 있습니다.
3.  **부분적인 커버리지**: 자동화된 테스트는 모든 경우를 다루지는 못할 수 있습니다. 이는 수동으로 테스트를 수행해야 하는 경우가 있음을 의미합니다.
4.  **유지보수 필요**: 자동화된 테스트를 만든 후, 애플리케이션 변경에 따라 테스트 코드를 수정해야 할 때가 있습니다. 이는 유지보수 비용을 증가시키며, 테스트 실행 결과의 신뢰도를 유지하기 위해 필수적입니다.

- **TDD(Test-Driven Development)란 무엇인가요? TDD의 장점과 단점은 무엇일까요?**

TDD(Test-Driven Development)는 소프트웨어 개발 방법론 중 하나로, 테스트를 먼저 작성하고 그 테스트를 통과하기 위한 코드를 작성하는 개발 방법론입니다. TDD는 테스트 코드 작성, 코드 작성 및 리팩토링으로 이루어져 있습니다.

**TDD의 장점**:

1.  **코드 품질 향상**: TDD는 코드 품질을 향상시키는데 도움을 줍니다. TDD를 사용하면 개발자는 코드가 올바르게 작성되었는지를 확인할 수 있으며, 코드가 변경될 때마다 테스트를 실행하므로 기능이 제대로 작동하는지 계속해서 확인할 수 있습니다.
2.  **버그 발견 및 수정 용이**: TDD는 버그를 발견하고 수정하기 쉽도록 돕습니다. TDD를 사용하면 테스트를 통과하지 못하는 코드가 발견될 때 즉시 확인하고 수정할 수 있으므로 버그 발견 및 수정 시간을 단축시킬 수 있습니다.
3.  **코드 이해도 향상**: TDD는 코드 이해도를 향상시키는데 도움을 줍니다. TDD를 사용하면 개발자는 각 기능이 어떻게 작동하는지 이해하고, 테스트를 통해 코드와 기능의 동작 방식을 더욱 잘 이해할 수 있습니다.
4.  **안정성 확보**: TDD는 안정성을 보장하는데 도움을 줍니다. 테스트 코드를 작성하면서 버그를 예방하고, 기능을 확인하면서 안정성을 보장할 수 있습니다.

**TDD의 단점**:

1.  **초기 학습 비용**: TDD를 사용하려면 개발자가 테스트 코드 작성 방법을 익혀야 합니다. 이는 초기에는 학습 비용이 많이 들 수 있습니다.
2.  **추가적인 시간 소요**: TDD는 테스트 코드를 작성하고, 코드를 작성하고, 리팩토링하는 과정이 있기 때문에 개발에 더 많은 시간이 필요할 수 있습니다.
3.  **완벽한 커버리지 보장 어려움**: TDD는 모든 경우를 커버하지 않을 수 있습니다. 이는 완벽한 테스트 커버리지를 보장하기 위해서는 추가적인 테스트가 필요할 수 있다는 것을 의미합니다.
4.  **잘못된 테스트 케이스 작성 가능성**: TDD를 사용하면 개발자가 테스트 케이스를 작성하는데 어려움을 겪을 수 있습니다. 이는 테스트 케이스를 작성하는 방법에 대한 이해 부족으로 인해 테스트 케이스가 잘못 작성될 가능성이 있습니다. 이는 실제 코드를 검증하지 않고 잘못된 테스트 결과를 가져올 수 있습니다.
5.  **설계 미비**: TDD는 작은 단위로 코드를 작성하는 것이 중요합니다. 이러한 방식은 작은 부분에서 작동하는 코드를 만들게 되므로 전체 시스템 설계에 대한 고려가 충분하지 않을 수 있습니다. 이는 전체 시스템을 설계하고 구현하는 방법을 충분히 고려하지 않았다면, 코드가 결합되고 확장성이 떨어질 가능성이 있습니다.
6.  **적용 제약**: 모든 프로젝트에서 TDD를 적용할 수 있는 것은 아닙니다. 프로젝트의 특성, 일정, 개발 환경 등에 따라 TDD를 적용하기 쉽지 않을 수 있습니다.

TDD는 소프트웨어 개발에 많은 장점을 제공하지만, 초기 학습 비용과 추가적인 시간 소요 등의 단점이 있습니다. 개발자는 프로젝트의 특성과 목표를 고려하여 TDD의 적용 여부를 결정해야 합니다.

- **테스트들 간의 계층에 따라 어떤 단계들이 있을까요?**

1.  **단위 테스트(Unit Test)**: 코드의 작은 단위, 일반적으로 클래스나 함수와 같은 개별 모듈에 대한 테스트를 수행합니다. 이 단계에서는 단위 테스트 프레임워크를 사용하여 코드의 작동 여부를 확인합니다.
2.  **통합 테스트(Integration Test)**: 단위 테스트를 통과한 모듈들이 통합되어 작동하는 시스템 전체에 대한 테스트를 수행합니다. 이 단계에서는 모듈들이 상호작용하는 방식, 데이터의 흐름 등을 검증합니다.
3.  **시스템 테스트(System Test)**: 시스템이 제대로 작동하는지, 기능 요구사항을 충족시키는지 등을 검증하는 단계입니다. 이 단계에서는 일반적으로 사용자 시나리오를 실행하여 시스템의 완전성을 검증합니다.
4.  **인수 테스트(Acceptance Test)**: 최종 사용자 또는 고객이 시스템이 요구사항을 충족시키는지 검증합니다. 이 단계에서는 일반적으로 사용자 시나리오를 실행하여 요구사항을 충족시키는지 확인합니다.

이러한 단계들은 계층적으로 구성되어 있으며, 하위 단계를 완료한 후 상위 단계로 이동하여 테스트를 수행합니다. 이를 통해 개발자는 코드의 작동 여부를 빠르게 확인하고, 시스템의 완성도를 높일 수 있습니다.

- **유닛 테스트, 통합 테스트, E2E 테스트는 각각 어떤 것을 뜻하나요?**

**유닛 테스트(Unit Test)**는 소프트웨어의 작은 단위, 즉 개별 모듈(함수, 메소드, 클래스 등)을 테스트하는 것입니다. 일반적으로 개발자가 수행하며, 각각의 모듈을 격리된 환경에서 실행하여 기능이 제대로 작동하는지 확인합니다.

**통합 테스트(Integration Test)**는 개별 모듈이 상호작용하여 제대로 작동하는지를 테스트하는 것입니다. 이는 여러 개의 모듈을 함께 실행하여 모듈 간 인터페이스와 상호작용을 검증합니다.

**E2E 테스트(End-to-End Test)**는 시스템 전체에 대한 테스트를 수행하는 것입니다. 이는 사용자의 시나리오를 통해 시스템 전체를 테스트하며, 실제 사용자가 이용하는 것과 유사한 상황을 재현합니다. E2E 테스트는 통합 테스트와 유닛 테스트보다 더 높은 수준의 테스트를 수행합니다.

이러한 테스트들은 소프트웨어 개발 과정에서 중요한 역할을 합니다. 유닛 테스트는 개발자가 코드를 안정적으로 유지하고, 문제를 빠르게 해결하도록 도와주며, 통합 테스트는 각 모듈이 상호작용하여 예상대로 작동하는지 검증합니다. E2E 테스트는 시스템의 완전성을 검증하여 사용자 경험을 개선하고, 시스템의 신뢰성을 높이는데 도움을 줍니다.

- **테스트에 있어서 Stub과 Mock은 어떤 개념을 가리키는 것일까요?**

Stub과 Mock은 테스트에서 자주 사용되는 용어로, 특정 객체나 모듈이나 메소드와 상호작용하는 경우 이를 대체하기 위한 가상의 객체나 모듈이나 메소드를 의미합니다.

Stub은 특정 메소드나 함수 등이 호출될 때, 미리 지정된 결과를 반환하는 객체입니다. 실제 구현이 아니라 테스트에서 사용하기 위한 임시적인 구현체입니다. 예를 들어, 네트워크 호출이나 파일 입출력 등은 시간이 오래 걸리기 때문에 테스트에서는 해당 기능을 가상의 데이터나 로컬 파일 등으로 대체할 수 있습니다.

반면, Mock은 테스트 도중에 특정 객체나 모듈이 예상대로 상호작용하는지 검증하기 위한 객체입니다. 예를 들어, 객체 A가 객체 B와 상호작용하는 경우, 객체 B 대신 Mock 객체를 만들어 테스트 중에 상호작용을 검증할 수 있습니다. 이때, Mock 객체는 객체 B와 동일한 인터페이스를 가지고 있어야 합니다.

- **Jest는 어떤 일을 하며 어떻게 사용하는 테스트 프레임워크일까요?**

Jest는 Facebook에서 개발된 자바스크립트 테스트 프레임워크입니다. Jest는 유닛 테스트, 통합 테스트, E2E 테스트를 모두 지원하며, 자동화된 테스트 실행, 코드 커버리지 리포트 생성, 모의 객체(Mock) 생성 등의 기능을 제공합니다.

Jest는 기본적으로 Jasmine 테스트 프레임워크를 기반으로 하며, 자체적으로 테스트 러너(Test Runner)와 어사션이션 라이브러리(Assertion Library), 그리고 테스트 더블(Test Double) 라이브러리인 Jest Mocks를 포함하고 있습니다.

Jest는 간단한 설정만으로도 빠르게 테스트를 시작할 수 있습니다. 보통 프로젝트의 루트 디렉토리에 **jest.config.js** 파일을 생성하고, 필요한 설정들을 추가합니다. Jest는 기본적으로 **\_\_tests\_\_** 폴더 내부에 있는 **.test.js** 또는 **.spec.js** 파일을 테스트 파일로 인식하며, **npm test** 명령어로 테스트를 실행할 수 있습니다.

Jest는 많은 기능과 확장성을 제공하기 때문에, 자바스크립트 프로젝트에서 테스트를 작성하고 실행할 때 많이 사용되는 테스트 프레임워크 중 하나입니다.

- **Jest 이외의 테스트 프레임워크는 어떤 것이 있고 어떤 장단점이 있을까요?**

- **Mocha**

- JavaScript 및 Node.js에서 가장 인기있는 테스트 프레임워크 중 하나입니다.
- 유연성이 높아서 원하는 테스트 환경을 설정할 수 있습니다.
- 어사션 라이브러리를 자유롭게 선택할 수 있습니다.
- 비동기 테스트를 지원합니다.

- **Jasmine**

- Behavior-Driven Development(BDD) 스타일로 테스트를 작성할 수 있습니다.
- 테스트 러너, 어사션 라이브러리, 스파이(Spy), 스텁(Stub) 등을 내장하고 있습니다.
- 비동기 테스트를 지원합니다.
- 설정이 복잡하지 않아 초보자가 쉽게 사용할 수 있습니다.

- **Tape**

- 간단하고 가벼운 테스트 프레임워크입니다.
- 테스트 파일을 모듈로 작성할 수 있습니다.
- 웹 브라우저 및 Node.js에서 동작합니다.
- 실시간 코드 커버리지 리포트를 생성할 수 있습니다.

- **Ava**

- Node.js에서 동작하는 가장 빠른 테스트 프레임워크 중 하나입니다.
- 동시성 테스트를 지원하여 다중 코어 CPU에서 빠른 실행이 가능합니다.
- ES6 모듈을 기본으로 지원합니다.
- 비동기 테스트를 지원합니다.

이 외에도 많은 테스트 프레임워크가 있습니다.

- **Puppeteer는 어떤 일을 하며 어떻게 사용하는 테스트 프레임워크일까요?**

Puppeteer는 구글에서 개발한 Headless Chrome/Chromium Node.js API입니다. Headless 브라우저는 GUI가 없는 브라우저이며, 이를 활용하여 웹 애플리케이션을 자동화하고 테스트하는 데 사용됩니다.

Puppeteer를 사용하면 사용자의 동작과 유사하게 웹 페이지를 제어할 수 있습니다. 즉, 마우스와 키보드 입력, 스크린샷 캡처, DOM 엘리먼트의 선택 및 조작 등을 자동으로 수행할 수 있습니다.

Puppeteer를 사용하면 다음과 같은 것들이 가능합니다.

- **웹 페이지 자동화**: 로그인, 양식 작성, 버튼 클릭 등 웹 페이지 내의 작업을 자동화합니다.
- **스크린샷 캡처**: 웹 페이지의 스크린샷을 자동으로 캡처합니다.
- **웹 크롤링**: 웹 페이지에서 데이터를 스크래핑합니다.
- **테스트 자동화**: 자동화된 테스트를 수행하여 웹 애플리케이션을 테스트합니다.

Puppeteer는 다른 테스트 프레임워크와 함께 사용될 수 있습니다. 예를 들어, Jest와 함께 사용하면 Jest-Puppeteer 라이브러리를 사용하여 테스트를 자동화할 수 있습니다. Jest-Puppeteer를 사용하면 Puppeteer를 사용하여 자동화된 테스트를 작성하고 실행할 수 있습니다.

## Quest

- 직전 퀘스트의 메모장의 서버와 클라이언트 각 부분에 유닛 테스트, 통합 테스트, E2E 테스트 등을 추가해 보세요.
  - `npm test` 명령을 통해 모든 테스트가 돌고 그 결과를 출력할 수 있어야 합니다.

## Advanced

- 테스트의 커버리지는 어떤 개념일까요? 프로젝트에서 테스트의 커버리지는 어떻게 접근하는 것이 좋을까요?

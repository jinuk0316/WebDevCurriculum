# Quest 11. RDB의 기초와 ORM

## Introduction

- 이번 퀘스트에서는 데이터베이스를 다루는 방법에 대해 알아보겠습니다.

## Topics

- RDBMS
- MySQL
- ORM
- Hash
  - scrypt

## Resources

- [MySQL 101 – The basics](https://www.globo.tech/learning-center/mysql-101-basics/)
- [Sequelize](https://sequelize.org/)
- [안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)

## **Checklist**

- **RDBMS 테이블의 정규화는 무엇인가요?**

관계형 데이터베이스(RDBMS)의 테이블 정규화(normalization)는 데이터를 중복 없이 효율적으로 저장하기 위한 프로세스입니다. 데이터를 정규화함으로써, 데이터 중복을 제거하고, 데이터 일관성을 유지할 수 있으며, 데이터 변경시 발생할 수 있는 이상 현상을 방지할 수 있습니다.

보통 테이블을 정규화할 때는, 일정한 규칙에 따라 테이블을 분리하고, 각 테이블의 관계를 정의합니다. 이때 사용되는 규칙은 대부분 업계 표준으로 수용되는 5가지 정규형(normal forms)입니다.

- **1NF(First Normal Form)**: 테이블의 각 열은 원자 값(Atomic Value)만 포함해야 합니다.
- **2NF(Second Normal Form)**: 테이블이 1NF를 만족하면서, 기본 키를 제외한 모든 열이 기본 키에 대해 완전 함수 종속(Fully Functional Dependent)이어야 합니다.
- **3NF(Third Normal Form)**: 테이블이 2NF를 만족하면서, 기본 키를 제외한 모든 열이 기본 키에 대해 이행적 함수 종속(Transitive Functional Dependent)이 아니어야 합니다.
- **BCNF(Boyce-Codd Normal Form)**: 모든 결정자가 후보키(Candidate Key)인 테이블입니다.
- **4NF(Fourth Normal Form)**: 다중값 종속(Multivalued Dependency)을 제거하는 정규형입니다.

각 정규형은 이전 정규형을 충족하면서 더 높은 수준의 정규화를 의미합니다. 정규화를 수행할 때는, 가능한 높은 정규형에 도달하려고 노력하지만, 높은 정규형이 필요하지 않은 경우에는 낮은 정규형으로 설계할 수 있습니다.

- **MySQL 외의 RDB에는 어떤 것들이 있나요?**

일부 대표적인 RDBMS를 소개하면 다음과 같습니다.

- **Oracle**: 대규모 데이터베이스에서 사용되는 상용 RDBMS입니다. 유료 라이선스를 제공하며, 기업 환경에서 많이 사용됩니다.
- **Microsoft SQL Server**: Microsoft에서 개발한 RDBMS입니다. Windows 환경에서 많이 사용되며, 대규모 데이터베이스를 지원합니다.
- **PostgreSQL**: 오픈 소스 RDBMS로, ACID를 준수하며, 대규모 데이터베이스에 적합합니다. MySQL보다 더 많은 기능을 제공합니다.
- **SQLite**: 경량 RDBMS로, 소규모 웹 및 모바일 애플리케이션에 많이 사용됩니다. 파일 기반 데이터베이스로, 빠른 성능을 제공합니다.
- **IBM DB2**: IBM에서 개발한 RDBMS입니다. 대규모 데이터베이스를 지원하며, 대규모 기업에서 많이 사용됩니다.

이외에도 **MariaDB**등이 있습니다.

- **Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?**

- **NoSQL 데이터베이스**: 관계형 데이터베이스와 달리 스키마가 없거나 유연한 스키마를 가지고 있습니다. 대량의 비정형 데이터를 처리하기 위한 목적으로 사용되며, 예를 들어 웹 애플리케이션의 로그 데이터 등을 처리하는 데 사용됩니다. 대표적인 NoSQL 데이터베이스로는 MongoDB, Cassandra, Couchbase 등이 있습니다.
- **그래프 데이터베이스**: 데이터를 노드와 엣지(관계)로 구성된 그래프 형태로 저장하는 데이터베이스입니다. 예를 들어 소셜 네트워크에서 사용자와 친구 관계를 저장하는 데 사용됩니다. 대표적인 그래프 데이터베이스로는 Neo4j, ArangoDB 등이 있습니다.
- **메모리 데이터베이스**: 데이터를 디스크 대신 메모리에 저장하여 빠른 데이터 처리를 가능케 합니다. 주로 빠른 데이터 처리가 필요한 애플리케이션에서 사용됩니다. 대표적인 메모리 데이터베이스로는 Redis, Memcached 등이 있습니다.
- **컬럼 패밀리 데이터베이스**: 열 기반 데이터 저장 방식을 사용하는 데이터베이스입니다. 대량의 데이터를 저장하고 처리하기에 적합하며, OLAP(Online Analytical Processing) 분석 작업에 많이 사용됩니다. 대표적인 컬럼 패밀리 데이터베이스로는 Apache HBase, Cassandra 등이 있습니다.
- **객체 데이터베이스**: 객체 지향 프로그래밍에서 사용되는 객체를 저장하고 조회하는 데 사용됩니다. 객체 지향 프로그래밍에서 발생하는 문제를 해결하기 위해 개발된 데이터베이스입니다. 대표적인 객체 데이터베이스로는 Versant Object Database, ObjectDB 등이 있습니다.

- **RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?**

인덱싱은 RDBMS에서 테이블의 검색 속도를 높이기 위한 기술입니다. 인덱스는 특정 컬럼(열)을 기준으로 행(레코드)들을 정렬한 데이터 구조입니다.

인덱스를 생성하면 검색 시 해당 컬럼의 값을 참조하여 더 빠르게 검색할 수 있습니다. 인덱스는 일반적으로 B-Tree 또는 B+Tree의 형태로 구현됩니다. 이러한 트리 구조는 삽입, 삭제, 검색 등의 작업을 빠르게 수행할 수 있도록 설계되어 있습니다.

인덱스를 사용하면 데이터베이스 검색 속도가 빨라지며, 대량의 데이터를 검색해야 하는 경우 유용합니다. 그러나 인덱스를 생성하면 추가적인 디스크 공간과 메모리가 필요하므로, 인덱스를 남용하면 오히려 성능 저하를 일으킬 수 있습니다. 또한 인덱스를 생성할 때마다 데이터베이스의 성능에 영향을 미칠 수 있으므로, 인덱스를 생성하기 전에 신중하게 판단해야 합니다.

인덱스는 데이터베이스 설계 시 중요한 요소 중 하나이며, 적절한 인덱스를 사용하여 데이터베이스의 성능을 최적화할 수 있습니다.

- **ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?**

**장점**:

- **생산성 향상**: ORM은 개발자가 객체 지향적인 코드를 작성하면, 이를 자동으로 SQL 쿼리로 변환해줍니다. 이는 개발자가 직접 SQL을 작성하는 것보다 생산성을 향상시킬 수 있습니다.
- **DBMS 종속성 제거**: ORM은 개발자가 코드를 작성할 때, DBMS 종속적인 부분을 최소화합니다. 이는 다양한 DBMS에 대응할 수 있게 되어 코드의 재사용성과 유지보수성을 높일 수 있습니다.
- **보안성 향상**: ORM은 SQL Injection 공격과 같은 보안적 위협을 방지할 수 있는 방법을 제공합니다. ORM은 데이터에 대한 보안을 유지하면서 SQL Injection 공격으로부터 보호할 수 있습니다.
- **객체지향적인 설계**: ORM을 사용하면 객체지향적인 코드를 작성할 수 있습니다. 이는 개발자가 코드를 더 쉽게 이해하고 유지보수할 수 있도록 도와줍니다.

**단점**:

- **복잡성**: ORM을 사용하면 복잡한 코드를 작성해야 합니다. 이는 때로는 일반적인 SQL 쿼리 작성보다 더 복잡할 수 있습니다.
- **성능 저하**: ORM은 SQL을 자동으로 생성하기 때문에, 이를 최적화하지 못할 때 성능이 저하될 수 있습니다. 때로는 개발자가 직접 SQL 쿼리를 작성하는 것이 더 빠를 수 있습니다.
- **러닝 커브**: ORM을 사용하려면 개발자가 ORM의 구조와 사용법을 익혀야 합니다. 이는 ORM을 처음 사용하는 개발자에게는 학습 곡선을 가지고 올 수 있습니다.

따라서 ORM을 사용하는 것은 생산성과 유지보수성을 높이는 장점이 있지만, 이를 사용하면서 발생할 수 있는 성능 저하나 복잡성 등의 단점도 고려해야 합니다.

- **자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?**

- **Sequelize**: Node.js에서 사용되는 ORM으로 MySQL, PostgreSQL, SQLite, MSSQL 등 다양한 데이터베이스를 지원합니다.
- **TypeORM**: TypeScript와 JavaScript를 모두 지원하는 ORM으로 MySQL, PostgreSQL, SQLite, MSSQL, Oracle, MongoDB, MariaDB 등 다양한 데이터베이스를 지원합니다.
- **Prisma**: TypeScript와 JavaScript를 모두 지원하는 ORM으로 PostgreSQL, MySQL, SQLite, MSSQL 등 다양한 데이터베이스를 지원합니다.
- **Mongoose**: MongoDB를 위한 ODM(Object Data Mapping)으로 MongoDB에서 JavaScript 객체를 쉽게 다룰 수 있도록 해주는 라이브러리입니다.
- **Waterline**: 다양한 데이터베이스를 지원하는 ORM으로, MySQL, PostgreSQL, MongoDB, Redis, Cassandra, Oracle 등 다양한 데이터베이스를 지원합니다.

이 외에도, **LoopBack, Caminte, Bookshelf, Objection.js** 등 다양한 ORM 라이브러리가 존재합니다.

- **모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?**

모델 간의 관계는 크게 1:1, 1:N, N:M의 3가지로 분류됩니다.

1.  **1:1 관계**: 하나의 모델이 다른 하나의 모델과 연결되는 관계입니다. 예를 들어, 한 명의 사용자(User)가 하나의 프로필(Profile)을 가지는 경우, User 모델과 Profile 모델 간에 1:1 관계가 형성됩니다.
2.  **1:N 관계**: 하나의 모델이 다른 여러 모델과 연결되는 관계입니다. 예를 들어, 한 명의 사용자(User)가 여러 개의 게시글(Post)을 작성하는 경우, User 모델과 Post 모델 간에 1:N 관계가 형성됩니다.
3.  **N:M 관계**: 여러 개의 모델이 다른 여러 개의 모델과 연결되는 관계입니다. 예를 들어, 여러 명의 사용자(User)가 여러 개의 태그(Tag)를 가질 수 있는 경우, User 모델과 Tag 모델 간에 N:M 관계가 형성됩니다.

이러한 관계는 다양한 상황에서 사용됩니다. 예를 들어, 1:1 관계는 사용자와 프로필, 주문과 결제, 계좌와 사용자 정보 등에서 사용됩니다. 1:N 관계는 사용자와 게시글, 부서와 직원, 작업과 할 일 등에서 사용됩니다. N:M 관계는 사용자와 태그, 음악과 장르, 주문과 상품 등에서 사용됩니다.

이러한 관계는 데이터베이스 스키마를 설계할 때 중요합니다. 각각의 관계를 적절하게 설계하고 관리함으로써 데이터베이스의 성능과 유지 보수성을 향상시킬 수 있습니다.

- **DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?**

보안상의 이유로 암호를 평문으로 저장하는 것은 좋지 않습니다. 대신, 사용자의 암호를 안전하게 저장하기 위해 해시 함수와 같은 암호화 기술을 사용합니다.

해시 함수는 임의의 길이의 입력 값을 받아서 고정된 길이의 출력 값을 생성합니다. 이 출력 값은 입력 값의 특정한 속성을 보존하면서도 원본 값을 역산할 수 없도록 만들어진 값입니다. 예를 들어, SHA-256 해시 함수를 사용하면 입력 값의 길이에 상관없이 256비트의 출력 값을 얻을 수 있습니다.

이와 같은 해시 함수를 사용하여 사용자의 암호를 암호화하면 원래 암호를 복원할 수 없습니다. 대신에, 암호화된 값을 데이터베이스에 저장합니다. 그리고 사용자가 로그인하려고 할 때 입력한 암호를 같은 암호화 함수를 적용하여 암호화한 후, 데이터베이스에 저장된 암호화된 값과 비교하여 인증을 수행합니다.

이렇게 함으로써 데이터베이스에 저장된 사용자 암호를 노출하는 것을 방지하면서도 인증을 수행할 수 있습니다.

- **해시 함수에는 어떤 것이 있나요?**

1.  **MD5**: 128비트 출력 값을 생성하는 가장 널리 사용되는 해시 함수 중 하나입니다. 하지만 보안에 취약해져서 현재는 사용되지 않는 추세입니다.
2.  **SHA-1**: 160비트 출력 값을 생성하는 해시 함수입니다. MD5보다는 안전하지만, 최근에는 보안상의 이유로 사용을 자제하는 것이 좋습니다.
3.  **SHA-256, SHA-384, SHA-512**: 각각 256, 384, 512비트 출력 값을 생성하는 해시 함수입니다. 현재 가장 보안성이 높은 해시 함수 중 하나입니다.
4.  **bcrypt**: 주로 암호화에 사용되는 해시 함수입니다. 입력 값을 무작위의 salt 값과 함께 여러 번 해싱하여 생성된 값을 출력으로 사용합니다. 이러한 방법은 무차별 대입 공격(brute force attack)을 어렵게 만들어 보안성을 높입니다.
5.  **PBKDF2**: 비밀번호 기반 키 파생 함수입니다. 입력 값을 무작위의 salt 값과 함께 여러 번 해싱하여 생성된 값을 출력으로 사용합니다. bcrypt와 마찬가지로 보안성을 높입니다.
6.  **HMAC**: 메시지 인증 코드(Message Authentication Code)를 생성하는 해시 함수입니다. 입력 값과 함께 비밀 키를 사용하여 출력 값을 생성합니다. 데이터 무결성을 검증하는 데 사용됩니다.

- **사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?**

- 솔트(salt)를 사용하여 해시값을 생성합니다. 솔트는 암호화할 때 랜덤으로 생성된 문자열로, 같은 암호라도 솔트값이 다르면 해시값이 달라집니다. 이를 통해 레인보우 테이블(Rainbow Table) 공격을 방지할 수 있습니다.
- 해시 함수는 SHA-2, SHA-3, bcrypt, scrypt 등 보안에 강력한 해시 함수를 사용합니다. 이러한 알고리즘들은 해시 충돌의 가능성이 매우 낮고, 브루트 포스 공격을 방지할 수 있는 반복 횟수 등 보안 강화 기능을 제공합니다.
- 저장할 때 해싱된 값을 저장합니다. 암호화된 값과 솔트값을 저장합니다.

이러한 방법을 사용하면, 암호화된 비밀번호를 복호화하지 않아도 인증이 가능하며, 보안성도 강화됩니다.

## Quest

- 이번에는 메모장을 파일이 아닌 DB기반으로 만들어 보고자 합니다.
  - 적절한 테이블을 설계해 보세요.
  - Sequelize를 이용하여 데이터의 모델을 만들고 어플리케이션에 적용해 보세요.
  - 사용자의 비밀번호는 해싱을 통해 저장되어야 합니다.

## Advanced

- Object–relational impedance mismatch란 어떤 개념인가요?
- Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?
- 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?

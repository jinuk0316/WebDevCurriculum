# Quest 08. 웹 API의 기초

## Introduction

- 이번 퀘스트에서는 웹 API 서버의 기초를 알아보겠습니다.

## Topics

- HTTP Method
- node.js `http` module
  - `req`와 `res` 객체

## Resources

- [MDN - Content-Type Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type)
- [MDN - HTTP Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)
- [MDN - MIME Type](https://developer.mozilla.org/en-US/docs/Glossary/MIME_type)
- [Postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop)
- [HTTP Node.js Manual & Documentation](https://nodejs.org/api/http.html)

## **Checklist**

- **HTTP의 GET과 POST 메소드는 어떻게 다른가요?**

GET과 POST의 가장 큰 차이점은 데이터 전송 방식입니다. GET은 주로 데이터를 검색하는 데 사용되며, POST는 데이터를 전송하는 데 사용됩니다.

GET 요청은 URL 뒤에 쿼리 문자열을 추가하여 데이터를 전송합니다. 이 쿼리 문자열은 서버로 전송되고, 서버는 이를 읽어 데이터를 검색합니다.

반면에 POST 요청은 HTTP 본문을 통해 데이터를 전송합니다. 이는 GET 요청과는 달리 URL에 노출되지 않습니다. POST는 주로 로그인, 회원가입, 글쓰기 등과 같은 데이터를 전송해야 하는 경우에 사용됩니다.

GET 요청은 브라우저 캐시에 저장될 수 있으며, 캐시된 요청은 더 빠른 응답을 제공합니다. 따라서 GET 요청은 주로 정적 데이터를 요청하는 데 사용됩니다. 반면에 POST 요청은 브라우저 캐시에 저장되지 않으며, 보안상의 이유로 요청이 브라우저에 저장되지 않습니다.

또한, GET 요청은 보통 브라우저의 주소 표시줄에서 직접 호출됩니다. 따라서 URL에 쿼리 문자열이 노출되며, 이는 보안상 취약점이 될 수 있습니다. 반면에 POST 요청은 데이터가 HTTP 본문에 포함되어 있으므로, URL에 노출되지 않습니다.

따라서 GET과 POST는 각각 다른 목적과 상황에서 사용됩니다. GET은 데이터 검색에 사용되며, POST는 데이터 전송에 사용됩니다.

- **다른 HTTP 메소드에는 무엇이 있나요?**

1.  **HEAD**: GET과 비슷하지만, 서버에서 응답 바디를 제외한 헤더만 전송합니다. 이 메소드는 서버에서 문서의 수정 날짜나 크기 등의 정보를 확인하는 데 사용됩니다.
2.  **PUT**: 지정된 URI에 새로운 리소스를 저장합니다. 예를 들어, 서버의 파일 시스템에 새 파일을 만들거나, 이미 존재하는 파일을 업데이트할 때 사용됩니다.
3.  **DELETE**: 지정된 URI의 리소스를 삭제합니다. 예를 들어, 서버의 파일 시스템에서 파일을 삭제할 때 사용됩니다.
4.  **PATCH**: 지정된 URI의 일부를 수정합니다. PUT과는 달리, PATCH는 리소스의 전체를 대체하지 않고 일부분만 수정할 때 사용됩니다.
5.  **OPTIONS**: 지정된 URI가 지원하는 메소드 목록을 검색합니다. 서버에 요청할 수 있는 메소드의 종류와 URI가 사용 가능한지 여부를 확인할 수 있습니다.
6.  **CONNECT**: 대상 리소스로의 네트워크 연결을 설정합니다. 이 메소드는 클라이언트가 원격 서버에 SSL/TLS 연결을 설정할 때 사용됩니다.
7.  **TRACE**: 클라이언트의 요청 메시지를 그대로 서버로 보내고, 서버에서는 응답 메시지를 그대로 클라이언트로 보냅니다. 이를 통해 클라이언트와 서버 간의 통신을 디버깅할 수 있습니다.

- **HTTP 서버에 GET과 POST를 통해 데이터를 보내려면 어떻게 해야 하나요?**

- GET 요청 보내기

- GET 요청은 URL 뒤에 파라미터를 붙여 보내는 방식입니다.
- 파라미터는 **?** 기호로 URL과 분리하고, 각각의 파라미터는 **&** 기호로 구분합니다.
- 예를 들어, **http://example.com?name=john&age=30**과 같은 URL은 **name**과 **age**라는 파라미터와 그 값으로 **john**과 **30**을 갖습니다.

- POST 요청 보내기

- POST 요청은 HTTP 요청 바디에 데이터를 실어 보내는 방식입니다.
- 요청 바디에 실어 보내는 데이터는 key-value 형태의 데이터가 될 수도 있고, 파일 업로드 등의 다른 형태의 데이터가 될 수도 있습니다.
- 예를 들어, HTML form을 통해 POST 요청을 보낼 때, form의 input 요소들은 **name** 속성을 갖고, 이를 key로, 입력된 값은 value로 POST 요청 바디에 실어 보내집니다.

서버 측에서는 각각의 요청을 처리하는 방식이 다르므로, 클라이언트가 보내는 요청에 따라 서버가 요청을 받아들일 수 있도록 적절한 핸들러를 구현해야 합니다. 또한, 클라이언트가 보내는 데이터에 대한 유효성 검사와 보안적인 이슈에 대해서도 고려해야 합니다.

- **HTTP 요청의 Content-Type 헤더는 무엇인가요?**

Content-Type 헤더는 다양한 MIME 타입을 지원하며, 주요 MIME 타입에는 아래와 같은 것들이 있습니다.

- **text/plain**: 일반 텍스트 형식
- **text/html**: HTML 문서 형식
- **application/json**: JSON 데이터 형식
- **application/xml**: XML 문서 형식
- **multipart/form-data**: 파일 업로드 형식

Content-Type 헤더를 지정하면 서버는 요청 메시지 바디를 올바르게 해석하여 처리할 수 있습니다.

예를 들어, Content-Type이 application/json인 경우, 서버는 요청 메시지 바디를 JSON 형식으로 파싱하여 데이터를 추출하고 처리할 수 있습니다.

- **Postman에서 POST 요청을 보내는 여러 가지 방법(form-data, x-www-form-urlencoded, raw, binary) 각각은 어떤 용도를 가지고 있나요?**

- **form-data:**

- HTTP 요청의 본문을 **key-value** 형태로 전송합니다.
- 이 방식은 파일 업로드나 멀티파트(form-data) 요청을 보낼 때 사용됩니다.
- 예를 들어, 파일 업로드를 위해 **key**를 **file**로, **value**를 업로드할 파일로 지정하여 요청을 보낼 수 있습니다.

- **x-www-form-urlencoded:**

- HTTP 요청의 본문을 **key=value** 형태로 전송합니다.
- 이 방식은 폼 데이터를 전송할 때 사용됩니다.
- 예를 들어, **key**를 **name**으로, **value**를 **John**으로 지정하여 요청을 보낼 수 있습니다.

- **raw:**

- HTTP 요청의 본문을 문자열로 전송합니다.
- 이 방식은 요청 바디가 JSON, XML, HTML 등의 형식을 갖는 경우 사용됩니다.
- 예를 들어, JSON 형식의 데이터를 전송할 때, **Content-Type**을 **application/json**으로 지정하고, JSON 형식의 데이터를 요청 바디에 문자열로 지정하여 요청을 보낼 수 있습니다.

- **binary:**

- HTTP 요청의 본문을 이진 데이터(binary data)로 전송합니다.
- 이 방식은 이미지나 동영상 등의 바이너리 데이터를 전송할 때 사용됩니다.
- 예를 들어, 이미지를 업로드할 때는 **Content-Type**을 **image/png** 등의 적절한 값으로 지정하고, 이미지 파일을 요청 바디에 이진 데이터로 지정하여 요청을 보낼 수 있습니다.

- **node.js의 http 모듈을 통해 HTTP 요청을 처리할 때,** **req와 res 객체에는 어떤 정보가 담겨있을까요?**

node.js의 **http** 모듈을 통해 HTTP 요청을 처리할 때, **req**와 **res** 객체는 각각 요청과 응답에 대한 정보를 담고 있습니다.

**req** 객체에는 다음과 같은 정보가 담겨 있습니다.

- **req.url**: 요청된 URL 정보
- **req.method**: 요청된 HTTP 메서드 정보 (GET, POST, PUT, DELETE 등)
- **req.headers**: 요청 헤더 정보
- **req.body**: 요청 바디 정보 (POST, PUT 등의 요청에서만 존재)

**res** 객체에는 다음과 같은 정보가 담겨 있습니다.

- **res.statusCode**: 응답 상태 코드 (200, 404, 500 등)
- **res.setHeader()**: 응답 헤더 설정 함수
- **res.write()**: 응답 바디 데이터 전송 함수
- **res.end()**: 응답 종료 함수

이 외에도, **req**와 **res** 객체에는 다양한 메서드와 속성이 존재하며, 이를 활용하여 요청과 응답을 처리할 수 있습니다. 예를 들어, **res.writeHead()** 메서드를 사용하여 응답 헤더를 설정하고, **res.write()** 메서드를 사용하여 응답 데이터를 전송할 수 있습니다. 또한, **req.url** 속성을 사용하여 요청 URL 정보를 파싱하거나, **req.method** 속성을 사용하여 요청 HTTP 메서드 정보를 확인할 수 있습니다.

- **node.js의 http 모듈을 통해 HTTP 요청을 처리할 때,** **GET과 POST에 대한 처리 형태가 달라지는 이유는 무엇인가요?**

node.js의 **http** 모듈을 통해 HTTP 요청을 처리할 때, GET과 POST에 대한 처리 형태가 달라지는 이유는 각각의 HTTP 메서드가 요청하는 데이터의 형태와 전송 방식이 다르기 때문입니다.

GET 요청은 일반적으로 URL을 통해 데이터를 전송합니다. 따라서, **http** 모듈에서 GET 요청의 데이터는 **req.url** 속성을 통해 파싱하여 가져옵니다. GET 요청의 데이터는 URL에 쿼리 스트링 형태로 전달되며, 이를 파싱하여 데이터를 추출합니다.

반면에, POST 요청은 요청 바디에 데이터를 담아 전송합니다. 따라서, **http** 모듈에서 POST 요청의 데이터는 **req.on('data')** 이벤트를 통해 스트림으로부터 가져옵니다. POST 요청의 데이터는 주로 HTML form, JSON 데이터 등의 형태로 전송되며, **Content-Type** 헤더를 통해 데이터의 형태를 지정합니다.

따라서, **http** 모듈에서 GET과 POST 요청을 처리할 때, 데이터를 가져오는 방식이 다르게 구현됩니다. GET 요청에서는 URL에서 데이터를 파싱하여 가져오고, POST 요청에서는 요청 바디에서 데이터를 스트림으로부터 가져옵니다.

- **만약 API 엔드포인트(URL)가 아주 많다고 한다면, HTTP POST 요청의 Content-Type 헤더에 따라 다른 방식으로 동작하는 서버를 어떻게 정리하면 좋을까요?**

1.  라우팅을 사용하여 구분: API 엔드포인트를 구분하기 위해 라우팅을 사용할 수 있습니다. 라우팅은 URL 경로를 기반으로 요청을 분배하는 것으로, HTTP POST 요청의 Content-Type 헤더에 따라 다르게 동작하는 API 엔드포인트를 각각의 경로에 매핑하여 구분할 수 있습니다.
2.  미들웨어를 사용하여 처리: 미들웨어는 요청과 응답의 중간에 위치하여 요청 처리 과정에서 추가적인 로직을 수행하는 것으로, HTTP POST 요청의 Content-Type 헤더에 따라 다르게 동작하는 서버를 처리하기 위해 미들웨어를 사용할 수 있습니다. 예를 들어, 요청 바디의 Content-Type 헤더 값을 확인하여 데이터를 파싱하는 미들웨어를 추가하여 HTTP POST 요청의 Content-Type 헤더에 따라 다른 데이터 처리 로직을 수행할 수 있습니다.
3.  컨트롤러를 사용하여 분리: 컨트롤러는 요청 처리 로직을 구현하는 것으로, HTTP POST 요청의 Content-Type 헤더에 따라 다르게 동작하는 서버를 처리하기 위해 컨트롤러를 사용할 수 있습니다. 예를 들어, 요청 바디의 Content-Type 헤더 값을 확인하여 데이터를 파싱하고, 파싱된 데이터를 기반으로 다른 컨트롤러를 호출하는 방식으로 HTTP POST 요청의 Content-Type 헤더에 따라 다른 처리 로직을 수행할 수 있습니다.

이러한 방법들을 사용하여 HTTP POST 요청의 Content-Type 헤더에 따라 다른 방식으로 동작하는 API 서버를 정리할 수 있습니다.

- **그 밖에 서버가 요청들에 따라 공통적으로 처리하는 일에는 무엇이 있을까요? 이를 어떻게 정리하면 좋을까요?**

1.  요청 로깅: 서버에서 발생하는 모든 요청들을 로깅하여 추적할 수 있도록 합니다.
2.  에러 처리: 서버에서 발생하는 모든 에러들을 처리하고, 에러가 발생할 경우 적절한 HTTP 응답 코드를 반환합니다.
3.  인증 및 권한 관리: 인증 및 권한 관리를 통해 요청한 클라이언트가 유효한지 확인하고, 적절한 권한이 있는지를 판단합니다.
4.  요청 파싱 및 검증: 요청 바디에서 필요한 데이터를 추출하고, 데이터의 유효성을 검증합니다.
5.  응답 포맷팅: 클라이언트가 요청한 데이터를 적절한 포맷으로 응답합니다.

이러한 공통적인 처리 작업들을 처리하기 위해 미들웨어를 사용하면 좋습니다. 미들웨어는 요청과 응답의 중간에 위치하여 요청 처리 과정에서 추가적인 로직을 수행하는 것으로, 요청과 응답을 가로채서 필요한 작업을 수행할 수 있습니다. 예를 들어, 로깅 미들웨어를 추가하여 모든 요청을 로깅하고, 에러 핸들링 미들웨어를 추가하여 발생하는 모든 에러를 처리할 수 있습니다. 이러한 방법을 사용하여 서버의 공통적인 처리 작업을 모듈화하고, 코드를 재사용할 수 있습니다.

## Quest

- 다음의 동작을 하는 서버를 만들어 보세요.
  - 브라우저의 주소창에 `http://localhost:8080`을 치면 `Hello World!`를 응답하여 브라우저에 출력합니다.
  - 서버의 `/foo` URL에 `bar` 변수로 임의의 문자열을 GET 메소드로 보내면, `Hello, [문자열]`을 출력합니다.
  - 서버의 `/foo` URL에 `bar` 키에 임의의 문자열 값을 갖는 JSON 객체를 POST 메소드로 보내면, `Hello, [문자열]`을 출력합니다.
  - 서버의 `/pic/upload` URL에 그림 파일을 POST 하면 서버에 보안상 적절한 방법으로 파일이 업로드 됩니다.
  - 서버의 `/pic/show` URL을 GET 하면 브라우저에 위에 업로드한 그림이 뜹니다.
  - 서버의 `/pic/download` URL을 GET 하면 브라우저에 위에 업로드한 그림이 `pic.jpg`라는 이름으로 다운로드 됩니다.
- expressJS와 같은 외부 프레임워크를 사용하지 않고, node.js의 기본 모듈만을 사용해서 만들어 보세요.
- 처리하는 요청의 종류에 따라 공통적으로 나타나는 코드를 정리해 보세요.
  > 해결

## Advanced

- 서버가 파일 업로드를 지원할 때 보안상 주의할 점에는 무엇이 있을까요?
